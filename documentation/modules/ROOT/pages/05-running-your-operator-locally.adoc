include::_attributes.adoc[]
= Running v0.0.1 locally

Ok, so you have deployed your operator and it works properly, but imagine for a moment does not and you want to run it locally.

//.*But wait, running our role in a vacuum?!*
//Obviously no, we need a Playbook to run our role and check if everything is alright or not. So please, create a new file call it //`playbook.yaml` copy the next content in it and place it in the project folder.

Before anything let's delete the `CR` to start clean.

[.console-input]
[source,bash,subs="attributes+"]
----
kubectl delete -f ./config/samples/{app_name}_v1_appdefinition.yaml -n $\{PROJECT_NAME}
----

[.console-input]
[source,bash,subs="attributes+"]
----
. ./settings.sh

oc describe sa/default -n $\{PROJECT_NAME}
----

Let’s extract the token used by the `default` service account.

[.console-input]
[source,bash,subs="attributes+"]
----
export SA_TOKEN=$(oc get secret -n $\{PROJECT_NAME} $(oc get sa/default -o json -n $\{PROJECT_NAME} | jq -r '.secrets[0].name') -o json | jq -r .data.token | base64 -D)
----

Now we can use that token to execute code as the service account does when the operator is deployed.

[.console-input]
[source,bash,subs="attributes+"]
----
kubectl --token=$\{SA_TOKEN} get pod -n $\{PROJECT_NAME}
----

Before we actually run the role manually and locally let’s scale the operator to zero.

[.console-input]
[source,bash,subs="attributes+"]
----
kubectl --token=$\{SA_TOKEN} scale deploy/$\{OPERATOR_NAME}-controller-manager --replicas=0 -n $\{PROJECT_NAME}
----

.A note regarding RBAC
[NOTE]
========
As you have probably guessed your operator runs as a pod using a unique service account. Well, this account needs some permissions and those are granted through a `RoleBinding` to a `Role` definition which you can find here `./config/rbac/role.yaml'. The content should look as follows:

[source,yaml]
----
include::example$operator-rbac.yaml[]
----
========

Let's run the logic or our operator locally using ansible...


[.console-input]
[source,bash,subs="attributes+"]
----
make install run
----

Now (from a second terminal) create a `CR` using the sample generated by the Operator SDK. 

TIP: Load environment with `. ./settings.sh` as we did before.

[.console-input]
[source,bash,subs="attributes+"]
----
kubectl apply -f ./config/samples/{app_name}_v1_appdefinition.yaml -n $\{PROJECT_NAME}
----

Have a look to the PODs and deployments.

[.console-input]
[source,bash,subs="attributes+"]
----
kubectl get pod -n $\{PROJECT_NAME}
----

The output should look like this.

[.console-output]
[source,bash,subs="attributes+"]
----
NAME                                READY   STATUS    RESTARTS   AGE
{crd_name_lc}-sample-bf69d6cdf-8ngz5   1/1     Running   0          29s
{crd_name_lc}-sample-bf69d6cdf-ln75m   1/1     Running   0          29s
----

[.console-input]
[source,bash,subs="attributes+"]
----
kubectl get deploy -n $\{PROJECT_NAME}
----

Expected output:

[.console-output]
[source,bash,subs="attributes+"]
----
NAME                READY   UP-TO-DATE   AVAILABLE   AGE
{crd_name_lc}-sample   2/2     2            2           46s
----

That means the operator logic works locally… using our local token, the
one you’re using with kubectl. That’s cheating a bit ;-)

Let’s do some cleaning, delete the {crd_name_lc} object.

[.console-input]
[source,bash,subs="attributes+"]
----
kubectl delete -f ./config/samples/{app_name}_v1_appdefinition.yaml -n $\{PROJECT_NAME}
----

Ok we're done with the manual tests, kbd:[Ctrl+C] to stop the local process and run this to undeploy the operator. 

[.console-input]
[source,bash,subs="attributes+"]
----
make undeploy
----